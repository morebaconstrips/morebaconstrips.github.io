<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="author" content="">
<meta name="description" content="Feb 2022 - Jul 2022
Project about biometric encryption for my bachelor thesis. I have developed an efficient algorithm for fingerprint recognition and matching. This algorithm served as the foundation of my research, which entails the implementation of a fast and highly secure algorithm of encryption and decryption using Shamir&amp;rsquo;s Secret Sharing scheme.
Image Processing The first part of the algorithm provides a sequence of operations aimed at making the input image as clear and legible as possible, in order to facilitate the minutiae extraction process." />
<meta name="keywords" content="" />
<meta name="robots" content="noodp" />
<meta name="theme-color" content="" />
<link rel="canonical" href="https://morebaconstrips.github.io/projects/thesis/" />


    <title>
        
            A Robust Fingerprint Data Encryption Technique for High Security Applications :: Gabriele Abbate  — Cybersecurity MSc student
        
    </title>





<link rel="stylesheet" href="/main.b78c3be9451dc4ca61ca377f3dc2cf2e6345a44c2bae46216a322ef366daa399.css" integrity="sha256-t4w76UUdxMphyjd/PcLPLmNFpEwrrkYhajIu82bao5k=">


    
        <link rel="stylesheet" type="text/css" href="custom.css">
    


    <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="manifest" href="/site.webmanifest">
    <link rel="mask-icon" href="/safari-pinned-tab.svg" color="">
    <link rel="shortcut icon" href="/favicon.ico">
    <meta name="msapplication-TileColor" content="">


<meta itemprop="name" content="A Robust Fingerprint Data Encryption Technique for High Security Applications">
<meta itemprop="description" content="Feb 2022 - Jul 2022
Project about biometric encryption for my bachelor thesis. I have developed an efficient algorithm for fingerprint recognition and matching. This algorithm served as the foundation of my research, which entails the implementation of a fast and highly secure algorithm of encryption and decryption using Shamir&rsquo;s Secret Sharing scheme.
Image Processing The first part of the algorithm provides a sequence of operations aimed at making the input image as clear and legible as possible, in order to facilitate the minutiae extraction process."><meta itemprop="datePublished" content="2022-09-17T18:57:26+02:00" />
<meta itemprop="dateModified" content="2022-09-17T18:57:26+02:00" />
<meta itemprop="wordCount" content="1587"><meta itemprop="image" content="https://morebaconstrips.github.io/" />
<meta itemprop="keywords" content="" />
<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://morebaconstrips.github.io/" /><meta name="twitter:title" content="A Robust Fingerprint Data Encryption Technique for High Security Applications"/>
<meta name="twitter:description" content="Feb 2022 - Jul 2022
Project about biometric encryption for my bachelor thesis. I have developed an efficient algorithm for fingerprint recognition and matching. This algorithm served as the foundation of my research, which entails the implementation of a fast and highly secure algorithm of encryption and decryption using Shamir&rsquo;s Secret Sharing scheme.
Image Processing The first part of the algorithm provides a sequence of operations aimed at making the input image as clear and legible as possible, in order to facilitate the minutiae extraction process."/>



    <meta property="og:title" content="A Robust Fingerprint Data Encryption Technique for High Security Applications" />
<meta property="og:description" content="Feb 2022 - Jul 2022
Project about biometric encryption for my bachelor thesis. I have developed an efficient algorithm for fingerprint recognition and matching. This algorithm served as the foundation of my research, which entails the implementation of a fast and highly secure algorithm of encryption and decryption using Shamir&rsquo;s Secret Sharing scheme.
Image Processing The first part of the algorithm provides a sequence of operations aimed at making the input image as clear and legible as possible, in order to facilitate the minutiae extraction process." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://morebaconstrips.github.io/projects/thesis/" /><meta property="og:image" content="https://morebaconstrips.github.io/" /><meta property="article:section" content="projects" />
<meta property="article:published_time" content="2022-09-17T18:57:26+02:00" />
<meta property="article:modified_time" content="2022-09-17T18:57:26+02:00" />







    <meta property="article:published_time" content="2022-09-17 18:57:26 &#43;0200 CEST" />












    </head>

    
        <body>
    
    
        <div class="container">
            <header class="header">
    <span class="header__inner">
        <a href="/" style="text-decoration: none;">
    <div class="logo">
        
            <span class="logo__mark">></span>
            <span class="logo__text ">
                gabriele.portfolio.sh</span>
            <span class="logo__cursor" style=
                  "
                   
                   ">
            </span>
        
    </div>
</a>


        <span class="header__right">
            
                <nav class="menu">
    <ul class="menu__inner"><li><a href="/about">~/about</a></li><li><a href="/projects">~/projects</a></li><li><a href="/writeups">~/writeups</a></li>
    </ul>
</nav>

                <span class="menu-trigger">
                    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24">
                        <path d="M0 0h24v24H0z" fill="none"/>
                        <path d="M3 18h18v-2H3v2zm0-5h18v-2H3v2zm0-7v2h18V6H3z"/>
                    </svg>
                </span>
            
        </span>
    </span>
</header>


            <div class="content">
                
    <main class="post">

        <div class="post-info">
            
            </p>
        </div>

        <article>
            <h2 class="post-title"><a href="https://morebaconstrips.github.io/projects/thesis/">A Robust Fingerprint Data Encryption Technique for High Security Applications</a></h2>

            
            
            

            <div class="post-content">
                <p>Feb 2022 - Jul 2022</p>
<hr>
<p>Project about biometric encryption for my bachelor thesis. I have developed an efficient algorithm for fingerprint recognition and matching. This algorithm served as the foundation of my research, which entails the implementation of a fast and highly secure algorithm of encryption and decryption using Shamir&rsquo;s Secret Sharing scheme.</p>
<h1 id="image-processing">Image Processing</h1>
<p>The first part of the algorithm provides a sequence of operations aimed at making the input image as clear and legible as possible, in order to facilitate the minutiae extraction process. The figure below shows the raw fingerprint image taken as input.</p>
<p><img src="/images/14_1_7.jpg#center" alt="Raw"></p>
<h3 id="normalization">Normalization</h3>
<p>The image is first normalized in order to eliminate the inconsistencies caused by lighting; by adjusting the grayscale levels, it is possible to standardize the intensity levels, thus improving the image contrast and avoiding annoying spikes in the grayscale spectrum. Once the mean values of the image are found, the variance is calculated.</p>
<p>The figure depicts the normalized fingerprint.</p>
<p><img src="/images/normalizzata.jpg" alt="Normalized"></p>
<h3 id="segmentation">Segmentation</h3>
<p>The normalization phase is followed by the segmentation phase, in which the fingerprint is extracted and isolated from the background of the image. The scan is divided into blocks of size W × W, within which the variance of the grayscale levels is calculated. This variance is then compared to a threshold T, and if the value is less than T, the block is considered as background and colored black.</p>
<p><img src="/images/segmentata.jpg" alt="normalized"></p>
<h3 id="smoothing">Smoothing</h3>
<p>In order to avoid false orientation estimates due to excessive noise, a low-pass filter is applied to the orientation map created in the previous step, and with the resulting output, the orientation of each pixel is recalculated. The low-pass filter used for smoothing is applied after the generation of the orientation map to eliminate directional discontinuities that were generated in the same phase. The figures below show the comparison between the orientation map before and after undergoing smoothing.</p>
<p><img src="/images/orientata_prima_smoothing.jpg" alt="before_smooth">
<img src="/images/orientata_dopo_smoothing.jpg" alt="after_smooth"></p>
<h3 id="gabor-filter">Gabor filter</h3>
<p>In this phase, the Gabor filter is used to extract features from the high-intensity points and create a binary image, where black pixels represent the ridges of the fingerprint and white pixels represent the valleys. Since we start from an image with 256 grayscale levels, all pixels whose value is below the threshold become (255, 255, 255), while those that exceed the minimum threshold become (0, 0, 0). The figure shows how the fingerprint image appears at the end of the preprocessing phase after applying the Gabor filter.</p>
<p><img src="/images/gabor.jpg" alt="gabor"></p>
<h3 id="skeletonization">Skeletonization</h3>
<p>The binary image created in the previous step is now subjected to a skeletonization process, thinning the black lines that represent the papillary ridges.</p>
<p><img src="/images/thin.jpg" alt="skeletonization"></p>
<h1 id="extraction-of-general-and-specific-characteristics">Extraction of general and specific characteristics</h1>
<p>Once the pre-processing phase is completed, all the means are in place to finally extract the minutiae and singularities from the analyzed fingerprint. The two main types of minutiae, which we will use for fingerprint matching, are terminations and bifurcations. For our purposes, it is convenient to represent a minutia as a quadruple (x, y, θ, t), where x and y are the coordinates expressing the position of the minutia in the image, θ is the direction of the minutia expressed in degrees, and t is the type of minutia (0 if it is a termination, 1 if it is a bifurcation).</p>
<h3 id="extraction-of-minutiae">Extraction of minutiae</h3>
<p>Having reached the end of the image processing, we are left with a refined structure from which it is now straightforward to extract the elements that will be used to align the fingerprints and verify their match. The decision was made to use the Crossing Number method to detect and classify the minutiae of the fingerprint.</p>
<p>Once all the minutiae of the fingerprint have been found, the terminations generated by the image segmentation are eliminated using the mask created during the same phase to blacken the background pixels.</p>
<p><img src="/images/compared_minutiae.jpg" alt="minutiae"></p>
<h3 id="extraction-of-singularities">Extraction of singularities</h3>
<p>Singularities are the configurations assumed by the dermal ridges in the central section; these have a more general character compared to minutiae (it is not by chance that they are also called general characteristics), and for this reason, they are used to classify fingerprints into categories. The extracted singularities include deltas, loops, and whorls, and the Poincaré Index method was used for this purpose.</p>
<p>At this point, two data structures have been created for each fingerprint, one containing the set of quadruples for the minutiae, and the other with the set of detected singularities, also in the form (x, y, θ, t).</p>
<h1 id="alignment">Alignment</h1>
<p>Once all the necessary information has been obtained, it is time to implement an algorithm that allows verifying whether an input fingerprint matches the one previously enrolled and stored in the database.</p>
<p>The first step is to select the singularities from both fingerprints to guide the alignment of the minutiae. If these minutiae do not have singularities of the same type, then neither the alignment nor the verification phase proceeds, and the algorithm terminates as a non-match. If they share the same singularity, the position and orientation values are saved. If they have multiple common singularities, the pair that most likely represents a correspondence between the template and the fingerprint to be verified is chosen, and the information is saved. To align the minutiae, their coordinates are first rotated and then translated based on the difference in orientation and position of the singularities.</p>
<p><img src="/images/alignment.png" alt="alignment"></p>
<h1 id="biometric-encryption">Biometric encryption</h1>
<p>The purpose of the algorithm I implemented is not only to verify that during authentication a person&rsquo;s fingerprint matches the one declared and previously saved in the database, but also, and above all, to conceal within the template fingerprint a 128-bit string that will be used for encrypting and decrypting any file using the symmetric key block cipher AES encryption scheme</p>
<h3 id="encryption-phase">Encryption phase</h3>
<p>After selecting the 128-bit symmetric key S, the Cyclic Redundancy Check (CRC) is computed, which will be used once the key is obtained to verify its integrity. Then, the 16 bits generated by the CRC are concatenated to the end of the secret, resulting in a 144-bit string SC. These bits are subsequently divided into 9 non-overlapping blocks, each containing 16 bits. Each of the values taken from SC is first converted to base 10 and then mapped among the coefficients of the polynomial P(u)^3. This yields a polynomial of degree 8. This polynomial will be used to create the vault in which the secret key is stored, specifically the 9 coefficients that make up P(u).</p>
<p>After saving the scan of the template fingerprint, whose minutiae (kept secret from third parties) represent the keys that will be used in the decryption phase to reconstruct the polynomial, it undergoes the enhancement pipeline. At this point, the values of x, y and θ of all the minutiae in the set are quantized, both to allow for a more or less wide margin of error and to enable the storage of coordinates with a reduced number of bits. Thus, for each minutia, a 16-bit binary string is created by concatenating the quantized values, converted to binary, of x, y, θ and t in that order</p>
<p>At this point, having constructed the polynomial P(u) and created a 16-bit binary string for each minutia of the template fingerprint, it is possible to build the vault of genuine values. This vault can be &ldquo;opened&rdquo; only if the input fingerprint has a minimum number of minutiae that can be considered matches (i.e., all minutiae overlapping with those of the template fingerprint). Since a precise number &rsquo;n&rsquo; of genuine values is required to construct the vault (the larger &rsquo;n&rsquo; is, the easier it is for an attacker to reconstruct the polynomial; however, too few genuine values in the vault could lead to access problems for the legitimate user), the first &rsquo;n&rsquo; distinct binary strings previously obtained from the template minutiae are selected.</p>
<p>After constructing the vault V of genuine values we need to hide the genuine values in order to allow only the legitimate user to find them. We create another set of values C, larger than V and consisting entirely of non-genuine values. This new set is composed of distinct values randomly generated, however, unlike the genuine values ui, these values do not belong to the polynomial. The union of V and C generates the Fuzzy Vault set FV, which contains the key to obtaining the coefficients of the polynomial that, when reconstructed, reveals the secret.</p>
<h3 id="decryption-phase">Decryption phase</h3>
<p>After aligning the input fingerprint, the values of these minutiae are quantized and the 16-bit binary strings are converted to base 10, as described earlier. A set of matches (M) is then created by comparing individual minutiae from the Mi set of the fingerprint to be verified with those in FV. Only the minutiae present in both sets are saved. For the decryption algorithm to reconstruct the polynomial, it is necessary for the M set to consist of at least 9 actual matches, given that the polynomial is of degree 8 (the effectiveness of this algorithm relies on the computational complexity of polynomial reconstruction).</p>
<p>To reconstruct the polynomial from the M set, Lagrange interpolation is used. Once all the coefficients found are converted to binary and concatenated, error checking is performed using the 16 bits at the end of the 144-bit string obtained. If the CRC (Cyclic Redundancy Check) shows no errors, then the string S&rsquo; of the first 128 bits found is indeed the secret S, and the algorithm terminates. Otherwise, attempts are made to reconstruct P(u) with the next subset of M. If the subsets of M finish without finding the secret, it means that the two fingerprints do not match, and the key remains hidden in the vault.</p>

            </div>
        </article>

        <hr />

        <div class="post-info">
            
            
  		</div>
    </main>

            </div>

            
                <footer class="footer">
    
    
</footer>

            
        </div>

        



<script type="text/javascript" src="/bundle.min.205d491810c28f95aa953fae884e1c27abe13fdf93ec63b882d0036b248d4a6282eb2d134e4e7225c6ad6e86db87b08488a361ca4a7383d01fcff43f3d57b9c3.js" integrity="sha512-IF1JGBDCj5WqlT&#43;uiE4cJ6vhP9&#43;T7GO4gtADaySNSmKC6y0TTk5yJcatbobbh7CEiKNhykpzg9Afz/Q/PVe5ww=="></script>



    </body>
</html>
